A continuaci√≥n te detallo c√≥mo puedes sincronizar (‚Äúimportar‚Äù) tanto veh√≠culos como piezas desde la API de Metasync y c√≥mo establecer la relaci√≥n entre ambas entidades en tu sistema:

1. Endpoints clave
Recurso	Ruta	Qu√© devuelve
RecuperarCambiosCanal	GET https://apis.metasync.com/Almacen/RecuperarCambiosCanal	Array de veh√≠culos y de piezasdesde una fecha dada
RecuperarCambiosVehiculosCanal	GET https://apis.metasync.com/Almacen/RecuperarCambiosVehiculosCanal	Array de veh√≠culos desde una fecha dada
RecuperarCambiosCanalEmpresa(opcional)	GET https://apis.metasync.com/Almacen/RecuperarCambiosCanalEmpresa	Igual que RecuperarCambiosCanal, filtrado por empresa
RecuperarCambiosVehiculosCanalEmpresa	GET https://apis.metasync.com/Almacen/RecuperarCambiosVehiculosCanalEmpresa	Igual que RecuperarCambiosVehiculosCanal, filtrado por empresa
Todos requieren en Headers:
* apikey: tu clave de API.
* fecha: fecha/hora ISO (‚ÄúYYYY-MM-DDThh:mm:ss‚Äù) desde la que quieres cambios.
* lastid: para paginaci√≥n, inicialmente 0.
* offset: cantidad de registros por p√°gina (m√°ximo 1000).
* [idempresa]: s√≥lo en endpoints ‚ÄúEmpresa‚Äù.

2. Estructura de los datos
Veh√≠culo
json
CopiarEditar
{
  "idLocal": 50937,
  "codigo": "...",
  "fechaMod": "2024-06-04T01:17:26",
  ‚Ä¶  
}
* idLocal: identificador √∫nico del veh√≠culo en el canal. 
Pieza
json
CopiarEditar
{
  "refLocal": 1194358,
  "idVehiculo": -1350842571,
  "codArticulo": "0100001",
  "descripcionArticulo": "NO IDENTIFICADO",
  "fechaMod": "2024-10-21T16:28:53",
  ‚Ä¶  
}
* refLocal: ID √∫nico de la pieza.
* idVehiculo: identificador local del veh√≠culo al que pertenece (coincide con idLocal del veh√≠culo). 

3. Flujo de importaci√≥n sugerido
1. Inicializar paginaci√≥n‚Ä®pseudo‚Ä®CopiarEditar‚Ä®‚Ä®‚Ä®lastid = 0
2. offset = 1000
3. ‚Ä®‚Ä®
4. Llamar a RecuperarCambiosCanal‚Ä®http‚Ä®CopiarEditar‚Ä®‚Ä®‚Ä®GET /Almacen/RecuperarCambiosCanal
5. Headers:
6.   apikey: TU_APIKEY
7.   fecha: 2025-05-01T00:00:00
8.   lastid: {{lastid}}
9.   offset: {{offset}}
10. ‚Ä®‚Ä®
11. Procesar respuesta
    * Por cada veh√≠culo en data.vehiculos:
        * Insertar/Actualizar en tu tabla vehiculos usando idLocal como clave.
    * Por cada pieza en data.piezas:
        * Insertar/Actualizar en tu tabla piezas usando refLocal como clave.
        * Almacenar idVehiculo para la relaci√≥n (clave for√°nea).
12. Actualizar paginaci√≥n‚Ä®pseudo‚Ä®CopiarEditar‚Ä®‚Ä®‚Ä®lastid = response.data.Paginacion.lastid
13. si response.data.Paginacion.count < offset: fin del bucle
14. sino: repetir desde el paso 2
15. ‚Ä®‚Ä®
16. (Opcional) Para sincronizaciones por empresa, usar RecuperarCambiosCanalEmpresa o RecuperarCambiosVehiculosCanalEmpresa, a√±adiendo el header idempresa.

4. Relaci√≥n piezas ‚Üî veh√≠culos
* La pieza contiene el campo idVehiculo, que es el mismo valor que el veh√≠culo expone en idLocal.
* En tu base de datos:‚Ä®sql‚Ä®CopiarEditar‚Ä®‚Ä®‚Ä®ALTER TABLE piezas
*   ADD COLUMN vehiculo_id INT;
* 
* -- Al importar:
* INSERT INTO piezas(refLocal, descripci√≥n, ..., vehiculo_id)
*   VALUES (..., pieza.codArticulo, ..., pieza.idVehiculo);
* ‚Ä®‚Ä®
* De este modo, puedes hacer joins:‚Ä®sql‚Ä®CopiarEditar‚Ä®‚Ä®‚Ä®SELECT p.*, v.*
*   FROM piezas p
*   JOIN vehiculos v
*     ON p.vehiculo_id = v.idLocal;
* ‚Ä®‚Ä®

5. Buenas pr√°cticas
* Fechas: almacena siempre la √∫ltima fecha de sincronizaci√≥n (fechaMod m√°s alta) para la siguiente llamada.
* Manejo de errores: controla c√≥digos 400, 500, 503 y vuelve a reintentar o registrar.
* Offset din√°mico: si tienes pocos registros, reduce offset para optimizar.
* Filtrado por empresa: si gestionas varios canales, usa los endpoints ‚ÄúEmpresa‚Äù para datos aislados.
Con este esquema tendr√°s un proceso robusto de importaci√≥n incremental de veh√≠culos y piezas, y la relaci√≥n entre ellos plenamente definida.
Fuentes

o4-mini-high
T√∫ dijiste:
revisa los ficheros que te he subido y revisa de nuevo la documentaci√≥n para establecer c√≥mo puedo importar veh√≠culos a una base de datos, importar piezas y que est√©n relacionadas

ChatGPT Plus

Pens√≥ durante 51 segundos
1. Esquema m√≠nimo de base de datos
sql
CopiarEditar
CREATE TABLE vehiculos (
    id_local        INT PRIMARY KEY,          -- idLocal
    id_empresa      INT NOT NULL,
    fecha_mod       TIMESTAMP,
    codigo          VARCHAR(20),
    bastidor        VARCHAR(50),
    matricula       VARCHAR(15),
    color           VARCHAR(30),
    kilometraje     INT,
    anyo_vehiculo   INT,
    codigo_motor    VARCHAR(40),
    codigo_cambio   VARCHAR(40),
    observaciones   TEXT,
    cod_marca       VARCHAR(10),
    nombre_marca    VARCHAR(80),
    cod_modelo      VARCHAR(20),
    nombre_modelo   VARCHAR(120),
    cod_version     VARCHAR(40),
    nombre_version  VARCHAR(120),
    combustible     VARCHAR(30),
    puertas         INT,
    potencia_hp     INT,
    potencia_kw     INT,
    cilindrada      INT,
    transmision     VARCHAR(120),
    alimentacion    VARCHAR(120),
    num_marchas     INT,
    ktype           VARCHAR(20)
    -- ‚Ä¶a√±ade cualquier campo que quieras conservar
);

CREATE TABLE piezas (
    ref_local       INT PRIMARY KEY,          -- refLocal
    id_empresa      INT NOT NULL,
    id_vehiculo     INT NOT NULL,             -- idVehiculo
    fecha_mod       TIMESTAMP,
    cod_familia     VARCHAR(10),
    descripcion_familia VARCHAR(120),
    cod_articulo    VARCHAR(20),
    descripcion_articulo VARCHAR(120),
    cod_version     VARCHAR(40),
    ref_principal   VARCHAR(120),
    precio          DECIMAL(10,2),
    peso            INT,
    ubicacion       VARCHAR(40),
    observaciones   TEXT,
    reserva         INT,
    tipo_material   INT,
    cod_almacen     VARCHAR(10),
    FOREIGN KEY (id_vehiculo) REFERENCES vehiculos(id_local)
);
CREATE INDEX idx_piezas_idvehiculo ON piezas(id_vehiculo);
Los nombres de columna siguen exactamente la nomenclatura que devuelve la API para evitar transformaciones innecesarias.

2. Endpoints que vas a usar
Caso de uso	Endpoint	Devuelve
S√≥lo veh√≠culos	GET /Almacen/RecuperarCambiosVehiculosCanal	data.vehiculos + paginaci√≥n
Veh√≠culos y piezas al mismo tiempo	GET /Almacen/RecuperarCambiosCanal	data.vehiculos y data.piezas
Filtrar por empresa	A√±ade el header idempresa y usa las variantes ‚Ä¶CanalEmpresa	
Cabeceras requeridas en todos los casos
* apikey ‚Äì tu clave de canal
* fecha ‚Äì ISO (ej. 2025-05-01T00:00:00)
* lastid ‚Äì 0 la primera vez, despu√©s el √∫ltimo recibido
* offset ‚Äì registros por p√°gina (1 ‚Äì 1000)

3. Pasos de la importaci√≥n (carga inicial o incremental)
pseudo
CopiarEditar
lastid = 0
fecha  = ultima_fecha_sincronizada       # ‚Äò1900-01-01T00:00:00‚Äô si es la primera
REPEAT
    resp = GET RecuperarCambiosCanal(fecha, lastid, offset=1000)
    BEGIN TRANSACTION
        # 1Ô∏è‚É£  Veh√≠culos
        FOR cada vehiculo IN resp.data.vehiculos:
            UPSERT vehiculos SET ‚Ä¶ WHERE id_local = vehiculo.idLocal

        # 2Ô∏è‚É£  Piezas
        FOR cada pieza IN resp.data.piezas:
            UPSERT piezas SET ‚Ä¶ WHERE ref_local = pieza.refLocal
            # ‚Äòid_vehiculo‚Äô = pieza.idVehiculo  üîó
    COMMIT
    lastid = resp.result_set.lastId
UNTIL resp.result_set.count < 1000
guardar(resp.data.vehiculos.max(fechaMod), lastid)
La transacci√≥n asegura que piezas y veh√≠culos quedan siempre en sincron√≠a.

4. Relaci√≥n pieza ‚Üí veh√≠culo
* Cada pieza lleva idVehiculo, ‚Äúidentificador local del veh√≠culo al que pertenece‚Äù (doc. de clase PiezaExport) .
* Ese valor se corresponde con idLocal en el objeto veh√≠culo .
* En la tabla piezas lo guardamos como id_vehiculo y lo marcamos como clave for√°nea.‚Ä®sql‚Ä®CopiarEditar‚Ä®‚Ä®‚Ä®SELECT p.ref_local, v.codigo, v.nombre_modelo
*   FROM piezas p
*   JOIN vehiculos v ON v.id_local = p.id_vehiculo;
* ‚Ä®‚Ä®
Nota sobre los n√∫meros negativos‚Ä®En los JSON de ejemplo los idVehiculo aparecen como enteros negativos mientras los idLocal son positivos. La documentaci√≥n indica que ambos identifican al mismo veh√≠culo; Metasync suele emplear un hash interno cuando el veh√≠culo todav√≠a no se ha insertado en tu inventario. En la pr√°ctica:
1. Procesa siempre primero veh√≠culos.
2. Si al insertar una pieza no existe su veh√≠culo, registra en log y re-intenta en el siguiente ciclo (normalmente el veh√≠culo llega en la misma o siguiente p√°gina).

5. Carga incremental diaria (sugerida)
1. Guarda en tu tabla de control:‚Ä®text‚Ä®CopiarEditar‚Ä®‚Ä®‚Ä®ultima_fecha_sync    lastId_vehiculos   lastId_piezas
2. ‚Ä®‚Ä®
3. Programa un job cada N minutos (o noche):
    * fecha = ultima_fecha_sync
    * lastid = 0
    * Ejecuta el bucle de la secci√≥n 3.
4. Al terminar, actualiza ultima_fecha_sync con la mayor fechaMod recibida.
Con este patr√≥n solo descargas lo que cambi√≥ desde la √∫ltima ejecuci√≥n; la API ya te da fechaMod en todos los registros .

6. Buenas pr√°cticas adicionales
Tema	Recomendaci√≥n
Paginaci√≥n	Mant√©n offset=1000 mientras count=1000; cuando baje, has llegado al final.
√çndices	‚Ä¢ vehiculos(id_empresa) ‚Ä¢ piezas(id_empresa) ‚Ä¢ piezas(id_vehiculo)
Integridad	Usa ON UPDATE/DELETE CASCADE si eliminas veh√≠culos.
Errores HTTP	429 / 503 ‚áí espera exponencial; 400/500 ‚áí registra y revisa.
Carga inicial	Empieza con un fecha muy antigua para traer todo el hist√≥rico.
Compresi√≥n	Activa Accept-Encoding: gzip para acelerar la descarga.
Filtrado por empresa	Si tu canal opera varios centros, sincroniza cada uno con sus endpoints ‚Äú‚Ä¶Empresa‚Äù en paralelo para reducir tr√°fico innecesario.

7. Ejemplo en Python (requests)
python
CopiarEditar
import requests, os, itertools

API = "https://apis.metasync.com/Almacen/RecuperarCambiosCanal"
HEADERS = {
    "apikey": os.getenv("METASYNC_KEY"),
    "fecha":  os.getenv("FECHA_SYNC"),   # p.e. '2025-05-01T00:00:00'
    "lastid": "0",
    "offset": "1000"
}

while True:
    r = requests.get(API, headers=HEADERS, timeout=30)
    r.raise_for_status()
    data = r.json()["data"]

    for v in data["vehiculos"]:
        upsert_vehiculo(v)          # tu l√≥gica DAL
    for p in data["piezas"]:
